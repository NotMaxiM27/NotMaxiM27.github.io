<!DOCTYPE html>
<html>
<head>
<title>CAVE simulator</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <link rel="stylesheet" crossorigin href="/assets/index-Dd6lRqA4.css">
</head>
<body>
<div id="info">
	CAVE Simulator. The head and teapot are draggable. <br />
	"L" See from Left Eye | "R" See from Right Eye | "S" toggle show scene | "Left Arrow" to widen cave walls | "Right Arrow" to narrow cave walls | "M" to reset cave walls  <br />
</div>

<!-- Check: https://threejs.org/docs/index.html#manual/en/introduction/Installation 
for alternative installations -->

<script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/controls/DragControls.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/geometries/TeapotGeometry.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/loaders/GLTFLoader.js"></script>

<script>
class DisplaySurface 
{
    constructor(name, origin, u_vector, v_vector) 
    {
        this.name = name;
        this.origin = origin;
        this.u = u_vector;
        this.v = v_vector;
        this.b = true;
    }

	viewMatrix(eye)
	{
        const uHat = this.u.clone().normalize();
        const vHat = this.v.clone().normalize();
        const nHat = new THREE.Vector3().crossVectors(uHat, vHat).normalize();

        const upVector = vHat.clone();

        const target = eye.clone().sub(nHat);

        var mat = new THREE.Matrix4();
        mat.lookAt(eye, target, upVector);

        const translate = new THREE.Matrix4().makeTranslation(-eye.x, -eye.y, -eye.z);

        mat.multiply(translate);

        return mat;
	}
	
    projectionMatrix(eye, znear, zfar)
    {
        const uHat = this.u.clone().normalize();
        const vHat = this.v.clone().normalize();
        const nHat = new THREE.Vector3().crossVectors(uHat, vHat).normalize();

        const va = this.origin.clone().sub(eye);
        const vb = this.origin.clone().add(this.u).sub(eye);
        const vc = this.origin.clone().add(this.v).sub(eye);

        const d = -va.dot(nHat);

        const left   = (uHat.dot(va) * znear) / d;
        const right  = (uHat.dot(vb) * znear) / d;
        const bottom = (vHat.dot(va) * znear) / d;
        const top    = (vHat.dot(vc) * znear) / d;

        const proj = new THREE.Matrix4();
        proj.makePerspective(left, right, top, bottom, znear, zfar);

        return proj;
    }
}


var renderer, scene, camera;
var displaySurfaces, displaySurfaceScene, displaySurfaceTargets;
var eyeCenter, eyeScene; 
var orbitControl;
var showScene = true;
var wallAngle = Math.PI / 2;
var angleStep = THREE.MathUtils.degToRad(2);

function rotatePointAroundAxis(P, B, axis, angle) {
    const v = P.clone().sub(B);
    v.applyAxisAngle(axis, angle);
    return B.clone().add(v);
}

function rotateVectorAroundAxis(u, axis, angle) {
    const v = u.clone();
    v.applyAxisAngle(axis, angle);
    return v;
}


function updateWallAngle() {
    
    const leftWall = displaySurfaces.find(d => d.name === "Left");
    const rightWall = displaySurfaces.find(d => d.name === "Right");

    const vBase = new THREE.Vector3(0, 300, 0);

    const B_left = new THREE.Vector3(-150, -150, -150);
    const axisY = new THREE.Vector3(0,1,0);
    const A_base_left = new THREE.Vector3(-150, -150, +150);
    const u_base_left = new THREE.Vector3(0,0,-300);
    
    const A_new_left = rotatePointAroundAxis(A_base_left, B_left, axisY, wallAngle - Math.PI/2);
    const u_new_left = rotateVectorAroundAxis(u_base_left, axisY, wallAngle - Math.PI/2);

    leftWall.origin.copy(A_new_left);
    leftWall.u.copy(u_new_left);
    leftWall.v.copy(vBase);


    const rightOrigin = new THREE.Vector3(150, -150, -150);
    const rightU = new THREE.Vector3(0, 0, 300);
    rightU.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2 - wallAngle);
    
    rightWall.origin.copy(rightOrigin);
    rightWall.u.copy(rightU);
    rightWall.v.copy(vBase);

    for (let cube of displaySurfaceScene.children) {
        const surf = displaySurfaces.find(d => d.name === cube.name);
        
        if (surf) {
            let p0, p1, p2, p3;
            
            if (surf.name === "Floor") {
                const v_BL = leftWall.origin;
                
                const v_FL = leftWall.origin.clone().add(leftWall.u);
                
                const v_FR = rightWall.origin;
                
                const v_BR = rightWall.origin.clone().add(rightWall.u);
                p0 = v_BL;
                p1 = v_BR;
                p2 = v_FR;
                p3 = v_FL;

            } else {
                const origin = surf.origin;
                const u = surf.u;
                const v = surf.v;
                
                p0 = origin;
                p1 = origin.clone().add(u);
                p2 = origin.clone().add(u).add(v);
                p3 = origin.clone().add(v);
            }
            const positionAttribute = cube.geometry.getAttribute('position');
            
            positionAttribute.setXYZ(0, p0.x, p0.y, p0.z);
            positionAttribute.setXYZ(1, p1.x, p1.y, p1.z);
            positionAttribute.setXYZ(2, p2.x, p2.y, p2.z);
            positionAttribute.setXYZ(3, p3.x, p3.y, p3.z);
            
            positionAttribute.needsUpdate = true;
            
            cube.geometry.computeVertexNormals();
        }
    }
}



function addDragControlToObjects()
{
    var objects = [];
    objects.push(scene.getObjectByName("Teapot"));
    objects.push(eyeScene.getObjectByName("Head"));
    
	//console.log(objects); 
	
    var controls = new THREE.DragControls( objects, camera, renderer.domElement );
    controls.addEventListener( 'hoveron', function ( event ) 
		{
            orbitControl.enabled = false;
        } );
    controls.addEventListener( 'hoveroff', function ( event ) 
	{
            orbitControl.enabled = true;
    } );
	controls.addEventListener( 'dragstart', function ( event ) 
		{
            event.object.material.emissive.set( 0xaaaaaa );
        } );
    controls.addEventListener( 'dragend', function ( event ) 
		{
            event.object.material.emissive.set( 0x000000 );
    } );
}

function createEyeScene()
{
    var IPD = 6.8; 
    eyeCenter = new THREE.Vector3(50, 20, 50);
    // eye positions relative to the head
    var eyeL = new THREE.Vector3( - IPD/2, 10, -6);
    var eyeR = new THREE.Vector3( + IPD/2, 10, -6);
    
    eyeScene = new THREE.Scene();

    // add sphere representing head
    var geometry = new THREE.SphereGeometry( 10, 32, 22 );
    var material = new THREE.MeshPhongMaterial( { color: 0xaaaaaa } );
    var head = new THREE.Mesh( geometry, material );
    head.name = "Head";
    head.position.set(eyeCenter.x, eyeCenter.y, eyeCenter.z);
    eyeScene.add(head);

    // add spheres representing L/R eyes
    var geometry = new THREE.SphereGeometry( 3, 32, 22 );
    var material = new THREE.MeshPhongMaterial( { color: 0xff0000 } );
    var sphere = new THREE.Mesh( geometry, material );
    sphere.name = "EyeL";
    sphere.position.set(eyeL.x, eyeL.y, eyeL.z);
    head.add(sphere);
	
    var geometry = new THREE.SphereGeometry( 3, 32, 22 );
    var material = new THREE.MeshPhongMaterial( { color: 0x0000ff } );
    var sphere = new THREE.Mesh( geometry, material );
    sphere.name = "EyeR";
    sphere.position.set(eyeR.x, eyeR.y, eyeR.z);
	head.add(sphere);
    
    createLights(eyeScene);
}

function createRenderer()
{
    renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true});
    renderer.autoClear = false;
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
}

function enableOrbitCamera(cam, renderer)
{
    orbitControl = new THREE.OrbitControls(cam, renderer.domElement );
    orbitControl.minDistance = 120;
    orbitControl.maxDistance = 50000;
}

function createLights(scn)
{
    var ambientLight = new THREE.AmbientLight(0x888888, 0.4);
    scn.add(ambientLight);
    var pointLight = new THREE.PointLight(0xffffff, 0.8);
	pointLight.position.z += 200;
    scn.add(pointLight);
}

let mixer;

function createScene()
{
    scene = new THREE.Scene();

    var geometry = new THREE.TeapotGeometry( 40, 15);
    var material = new THREE.MeshPhongMaterial( { color: 0xffffff } );
    var teapot = new THREE.Mesh(geometry, material);
    teapot.name = "Teapot";
    teapot.position.z-=70;
    scene.add( teapot );

    // TO REVIEW
    var loader = new THREE.GLTFLoader();

    loader.load("anime_girl_model.glb",
        function (gltf) {
            const model = gltf.scene;
            model.name = "Anime_girl";
            model.position.set(0, -20, -70);
            model.scale.set(30, 30, 30);
            scene.add(model);

            if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(model);
                gltf.animations.forEach((clip) => {
                    mixer.clipAction(clip).play();
                });
                console.log("Animazioni trovate:", gltf.animations.length);
            } else {
                console.log("Nessuna animazione trovata nel modello");
            }
        },
        function (xhr) {
            console.log((xhr.loaded / xhr.total * 100) + '% caricato');
        },
        function (error) {
            console.error('Errore nel caricamento del modello:', error);
        }
    );
    // END TO REVIEW
                
    createLights(scene);
}

// create a scene with 3D objects representing the display surfaces
function createDisplaySurfaceScene()
{
    displaySurfaceScene = new THREE.Scene();

    // add display surfaces
    for (var [index, displaySurface] of displaySurfaces.entries())
    {
        var origin = displaySurface.origin;
        var u = displaySurface.u;
        var v = displaySurface.v;
 
        const geometry = new THREE.BufferGeometry();

        const p0 = origin.clone();
        const p1 = origin.clone().add(u);
        const p2 = origin.clone().add(u).add(v);
        const p3 = origin.clone().add(v);

        const vertices = new Float32Array([
            p0.x, p0.y, p0.z,
            p1.x, p1.y, p1.z,
            p2.x, p2.y, p2.z,
            p3.x, p3.y, p3.z
        ]);

        const indices = [0, 1, 3, 1, 2, 3];
        
        const uvs = new Float32Array([
            0, 0,
            1, 0,
            1, 1,
            0, 1
        ]);

        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();

        geometry.getAttribute('position').setUsage(THREE.DynamicDrawUsage);

        var material = new THREE.MeshPhongMaterial({
            map: displaySurfaceTargets[index].texture,
            side: THREE.DoubleSide
        });
        
        var cube = new THREE.Mesh( geometry, material );
        cube.name = displaySurface.name;
        
        displaySurfaceScene.add(cube);
    }
    
    createLights(displaySurfaceScene);
}

function createDisplaySurfaceTargets()
{
    const SIZE = 1024;  // texture resolution
    displaySurfaceTargets = [];
    
    for (var v of displaySurfaces)       
        displaySurfaceTargets.push(new THREE.WebGLRenderTarget(SIZE, SIZE));
}


function createCamera()
{
    camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 10000 );
    camera.position.set( 100, 100, 300 );
    camera.lookAt( 0, 0, 0 );
}

function createDisplaySurfaces()
{
    displaySurfaces = [];
    // FRONT SCREEN
    var frontScreen = new DisplaySurface("Front", 
        new THREE.Vector3(-150.0, -150.0, -150.0), 
        new THREE.Vector3(300.0, 0.0,   0.0), 
        new THREE.Vector3(0.0, 300.0,   0.0));
    displaySurfaces.push(frontScreen);

    // LEFT SCREEN
    var leftScreen = new DisplaySurface("Left",
        new THREE.Vector3(-150.0, -150.0, 150.0), 
        new THREE.Vector3(0.0, 0.0,  -300.0), 
        new THREE.Vector3(0.0, 300.0,   0.0));
    displaySurfaces.push(leftScreen);
	
	// RIGHT SCREEN
    var rightScreen = new DisplaySurface("Right",
        new THREE.Vector3(150.0, -150.0, -150.0),
        new THREE.Vector3(0.0, 0.0, 300.0),
        new THREE.Vector3(0.0, 300.0, 0.0));
    displaySurfaces.push(rightScreen);

    // FLOOR SCREEN
    var floorScreen = new DisplaySurface("Floor",
        new THREE.Vector3(-150.0, -150.0, 150.0),
        new THREE.Vector3(300.0, 0.0, 0.0),
        new THREE.Vector3(0.0, 0.0, -300.0));
    displaySurfaces.push(floorScreen);
	
}

function getLeftEyePosition()
{
    var eye = eyeScene.getObjectByName("EyeL");
    return eye.getWorldPosition(new THREE.Vector3());
}

function getRightEyePosition()
{
    var eye = eyeScene.getObjectByName("EyeR");
    return eye.getWorldPosition(new THREE.Vector3());
}

function cameraFromViewProj(view, proj)
{
	var cam = camera.clone();
    var inv = new THREE.Matrix4();
	inv.copy(view).invert();
	cam.position.set(inv.elements[12], inv.elements[13], inv.elements[14]);
	cam.setRotationFromMatrix(view);
	cam.projectionMatrix = proj.clone();
	return cam;
}

const clock = new THREE.Clock();

// refresh function
var animate = function () {
    var gl = renderer.getContext();
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    if (mixer) mixer.update(delta);

    // 1. render scene objects
	renderer.setClearColor(0x808080);
    renderer.clear();
    if (showScene)
        renderer.render(scene, camera);
    
    // 2. render scene objects onto a texture, for each target
    for (let [index, displaySurface] of displaySurfaces.entries())
    {
        renderer.setRenderTarget(displaySurfaceTargets[index]);
        renderer.setClearColor(0x404040);
        renderer.clear();

		// left eye on RED channel
        gl.colorMask(1, 0, 0, 0); 
		var eye = getLeftEyePosition();
		var view = displaySurface.viewMatrix(eye);
		var proj = displaySurface.projectionMatrix(eye, 1, 1000);
        var leftCamera = cameraFromViewProj(view, proj);
        renderer.render(scene, leftCamera); 
    
		// right eye on GREEN, BLUE channels
		gl.colorMask(0, 1, 1, 0);
		var eye = getRightEyePosition();
		var view = displaySurface.viewMatrix(eye);
		var proj = displaySurface.projectionMatrix(eye, 1, 1000);
        var rightCamera = cameraFromViewProj(view, proj);
        renderer.clearDepth();
        renderer.render(scene, rightCamera); 
		
        gl.colorMask(1, 1, 1, 0);
    }
    // restore state
    renderer.setRenderTarget(null);
    renderer.setClearColor(0x000000);
  
    // 3. render display surfaces as (textured) quads
    renderer.render(displaySurfaceScene, camera);
	
	// 4. render eyes
    renderer.render(eyeScene, camera);
	
};


window.addEventListener( 'keydown', function ( event ) 
{
        switch ( event.code ) {
            case 'KeyL': 
                var eye = getLeftEyePosition();
                camera.position.set(eye.x, eye.y, eye.z); 
                break;
                
            case 'KeyR': 
                var eye = getRightEyePosition();
                camera.position.set(eye.x, eye.y, eye.z); 
                break;
                
            case 'KeyS':
                showScene = !showScene;
                break;
				
			case 'KeyT':
				var viewF = displaySurfaces[0].viewMatrix(new THREE.Vector3(50,20,100));
				var viewL = displaySurfaces[1].viewMatrix(new THREE.Vector3(50,20,100));
				var viewR = displaySurfaces[2].viewMatrix(new THREE.Vector3(50,20,100));
				var viewB = displaySurfaces[3].viewMatrix(new THREE.Vector3(50,20,100));
				console.log("View matrices:");
				console.log(viewF);
				console.log(viewL);
				console.log(viewR);
				console.log(viewB);
                var projF1 = displaySurfaces[0].projectionMatrix(new THREE.Vector3(0,0,0), 1, 1000);
				var projL1 = displaySurfaces[1].projectionMatrix(new THREE.Vector3(0,0,0), 1, 1000);
				var projR1 = displaySurfaces[2].projectionMatrix(new THREE.Vector3(0,0,0), 1, 1000);
				var projB1 = displaySurfaces[3].projectionMatrix(new THREE.Vector3(0,0,0), 1, 1000);
				console.log("Projection matrices 1:");
				console.log(projF1);
				console.log(projL1);
				console.log(projR1);
				console.log(projB1);
                var projF2 = displaySurfaces[0].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
				var projL2 = displaySurfaces[1].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
				var projR2 = displaySurfaces[2].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
				var projB2 = displaySurfaces[3].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
				console.log("Projection matrices 2:");
				console.log(projF2);
				console.log(projL2);
				console.log(projR2);
				console.log(projB2);
				break;

            case 'ArrowLeft':
                wallAngle -= angleStep;
                wallAngle = Math.max(THREE.MathUtils.degToRad(60), wallAngle);
                updateWallAngle();
                //console.log("Wall angle:", THREE.MathUtils.radToDeg(wallAngle).toFixed(1), "°");
                break;

            case 'ArrowRight':
                wallAngle += angleStep;
                wallAngle = Math.min(THREE.MathUtils.degToRad(120), wallAngle);
                updateWallAngle();
                //console.log("Wall angle:", THREE.MathUtils.radToDeg(wallAngle).toFixed(1), "°");
                break;
            case 'KeyM':
                wallAngle = Math.PI / 2;
                updateWallAngle();
                break;
                
                    
}
});



createRenderer();  			// create WebGL renderer
createDisplaySurfaces();	// Display surfaces
createDisplaySurfaceTargets(); // Textures for the display surfaces
createDisplaySurfaceScene();	// 3D objects for the display surfaces
updateWallAngle();
createEyeScene();	// spheres representing head + eyes
createScene();		// some objects to test (teapot...)
createCamera();		// a third-person camera
enableOrbitCamera(camera, renderer);  // basic camera control
addDragControlToObjects();	// allow some objects to be dragged
animate();


		</script>
    </body>
</html>
