<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CAVE simulator (WebXR)</title>
  <link rel="stylesheet" crossorigin href="/assets/index-Dd6lRqA4.css">
</head>
<body>
<div id="info">
  CAVE Simulator (WebXR). Head and teapot are draggable.<br/>
  "L" See from Left Eye | "R" See from Right Eye | "S" toggle show scene | "Left Arrow" to widen cave walls | "Right Arrow" to narrow cave walls | "M" to reset cave walls  <br />
</div>

<script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/controls/DragControls.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/geometries/TeapotGeometry.js"></script>

<script>
// ============================================================
// === DisplaySurface class
// ============================================================
class DisplaySurface {
  constructor(name, origin, u_vector, v_vector) {
    this.name = name;
    this.origin = origin;
    this.u = u_vector;
    this.v = v_vector;
    this.b = true;
  }
  viewMatrix(eye) {
    const uHat = this.u.clone().normalize();
    const vHat = this.v.clone().normalize();
    const nHat = new THREE.Vector3().crossVectors(uHat, vHat).normalize();
    const upVector = vHat.clone();
    const target = eye.clone().sub(nHat);
    const mat = new THREE.Matrix4();
    mat.lookAt(eye, target, upVector);
    const translate = new THREE.Matrix4().makeTranslation(-eye.x, -eye.y, -eye.z);
    mat.multiply(translate);
    return mat;
  }
  projectionMatrix(eye, znear, zfar) {
    const uHat = this.u.clone().normalize();
    const vHat = this.v.clone().normalize();
    const nHat = new THREE.Vector3().crossVectors(uHat, vHat).normalize();
    const va = this.origin.clone().sub(eye);
    const vb = this.origin.clone().add(this.u).sub(eye);
    const vc = this.origin.clone().add(this.v).sub(eye);
    const d = -va.dot(nHat);
    const left = (uHat.dot(va) * znear) / d;
    const right = (uHat.dot(vb) * znear) / d;
    const bottom = (vHat.dot(va) * znear) / d;
    const top = (vHat.dot(vc) * znear) / d;
    const proj = new THREE.Matrix4();
    proj.makePerspective(left, right, top, bottom, znear, zfar);
    return proj;
  }
}

// ============================================================
// === Globals
// ============================================================
let renderer, scene, camera;
let displaySurfaces, displaySurfaceScene, displaySurfaceTargets;
let eyeCenter, eyeScene;
let headMesh, eyeLMesh, eyeRMesh; 

let orbitControl, mixer;
let showScene = true;
let wallAngle = Math.PI / 2;
const angleStep = THREE.MathUtils.degToRad(2);
let xrSession = null;
let vrRig;
let controllerL, controllerR;
let lastButtonState = [false, false, false, false];
let raycaster;
let INTERSECTED = null; 
let tempMatrix = new THREE.Matrix4();
let grabbableObjects = [];

const controllerGripState = {
    isGrabbing: false,
    grabbedObject: null
};

// ============================================================
// === Helper functions
// ============================================================
function rotatePointAroundAxis(P, B, axis, angle) {
  const v = P.clone().sub(B);
  v.applyAxisAngle(axis, angle);
  return B.clone().add(v);
}
function rotateVectorAroundAxis(u, axis, angle) {
  const v = u.clone();
  v.applyAxisAngle(axis, angle);
  return v;
}

function setupXRControllers() {
    controllerL = renderer.xr.getController(0);
    dolly.add(controllerL);

    controllerR = renderer.xr.getController(1);
    dolly.add(controllerR);

    controllerR.addEventListener('selectstart', onSelectStart);
    controllerR.addEventListener('selectend', onSelectEnd);

    const controllerGeom = new THREE.SphereGeometry(0.05, 16, 8);
    const controllerMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
    
    const meshL = new THREE.Mesh(controllerGeom, controllerMat);
    const meshR = new THREE.Mesh(controllerGeom, controllerMat.clone());
    
    controllerR.add(meshR);

    const lineGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, -1) 
    ]);
    const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
    const line = new THREE.Line(lineGeom, lineMat);
    line.name = 'rayLine'; 
    line.scale.z = 1000; 
    controllerR.add(line);
}

// ============================================================
// === Grab and hover functions
// ============================================================

function onSelectStart(event) {
    if (INTERSECTED) {
        const objectToGrab = INTERSECTED;
        
        controllerR.attach(objectToGrab); 
        
        controllerGripState.isGrabbing = true;
        controllerGripState.grabbedObject = objectToGrab;
        
        objectToGrab.material.emissive.set( 0xaaaaaa );
    }
}

function onSelectEnd(event) {
    if (controllerGripState.isGrabbing && controllerGripState.grabbedObject) {
        const grabbed = controllerGripState.grabbedObject;

        grabbed.material.emissive.set( 0x2D2D2D );

        if (grabbed.name === "Teapot" || grabbed.name === "Tube") {
            scene.attach(grabbed);
        } else if (grabbed.name === "Head") {
            eyeScene.attach(grabbed);
        } else if (grabbed.name === "EyeL" || grabbed.name === "EyeR") {
            if (headMesh) {
                headMesh.attach(grabbed);
            } else {
                eyeScene.attach(grabbed);
            }
        } else {
            scene.attach(grabbed);
        }
        
        const line = controllerR.getObjectByName('rayLine');
        if (line) line.scale.z = 1000;

        controllerGripState.isGrabbing = false;
        controllerGripState.grabbedObject = null;
    }
}

function handleXRRaycaster() {
    if (!renderer.xr.isPresenting || !controllerR) return;

    const line = controllerR.getObjectByName('rayLine');

    if (controllerGripState.isGrabbing) {
        if (INTERSECTED) {
             INTERSECTED = null;
        }
        //if (line) line.scale.z = 0; 
        return;
    }
    
    tempMatrix.identity().extractRotation(controllerR.matrixWorld);
    
    raycaster.ray.origin.setFromMatrixPosition(controllerR.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

    grabbableObjects.forEach(obj => obj.updateMatrixWorld(true));

    const intersects = raycaster.intersectObjects(grabbableObjects);

    if (intersects.length > 0) {
        if (line) {
            line.scale.z = intersects[0].distance;
        }

        const newIntersected = intersects[0].object;
        
        if (INTERSECTED !== newIntersected) {
            if (INTERSECTED) {
                INTERSECTED.material.emissive.set(0x000000);
            }
            
            INTERSECTED = newIntersected;
            INTERSECTED.material.emissive.set(0x2D2D2D);
        }
    } else {
        if (line) {
            line.scale.z = 1000;
        }

        if (INTERSECTED) {
            INTERSECTED.material.emissive.set(0x000000);
        }
        INTERSECTED = null;
    }
}

function checkXRControllerButtons() {
  if (renderer.xr.isPresenting) {
    const ses = renderer.xr.getSession();

    for (let i = 0; i < ses.inputSources.length; i++) {
      const input = ses.inputSources[i];
      if (input && input.gamepad && input.gamepad.buttons) {
        const btns = input.gamepad.buttons; 
        
        // 0:trigger, 1:grip, 4:A, 5:B

        if (btns[5]) { 
          if (btns[5].pressed && !lastButtonState[i * 2]) {
            if (i === 0) {
                if(eyeLMesh) dolly.position.copy(eyeLMesh.getWorldPosition(new THREE.Vector3()));
            } else if (i === 1) {
              showScene = !showScene;
            }
            lastButtonState[i * 2] = true;
          }
          if (!btns[5].pressed) lastButtonState[i * 2] = false;
        }
        if (btns[4]) { 
          if (btns[4].pressed && !lastButtonState[i * 2 + 1]) {
            if (i === 0) {
                 if(eyeRMesh) dolly.position.copy(eyeRMesh.getWorldPosition(new THREE.Vector3()));
            } else if (i === 1) {
              wallAngle = Math.PI/2; updateWallAngle();
            }
            lastButtonState[i * 2 + 1] = true;
          }
          if (!btns[4].pressed) lastButtonState[i * 2 + 1] = false;
        }
        if (btns[1]) { 
          if (btns[1].pressed && !lastButtonState[i * 2 + 1]) {
            if (i === 0) {
                wallAngle += angleStep * 0.1;
                wallAngle = Math.min(THREE.MathUtils.degToRad(120), wallAngle);
                updateWallAngle();
            } else if (i === 1) {
                wallAngle -= angleStep * 0.1;
                wallAngle = Math.max(THREE.MathUtils.degToRad(60), wallAngle);
                updateWallAngle();
                }
            lastButtonState[i * 2 + 1] = true;
          }
          if (!btns[1].pressed) lastButtonState[i * 2 + 1] = false;
        }
      }
    }
  }
}

// ============================================================
// === Wall updates
// ============================================================
function updateWallAngle() {
  const leftWall = displaySurfaces.find(d => d.name === "Left");
  const rightWall = displaySurfaces.find(d => d.name === "Right");
  const vBase = new THREE.Vector3(0, 300, 0);
  const axisY = new THREE.Vector3(0,1,0);

  // === LEFT WALL ===
  const B_left = new THREE.Vector3(-150, -150, -150);
  const A_base_left = new THREE.Vector3(-150, -150, +150);
  const u_base_left = new THREE.Vector3(0,0,-300);
  const A_new_left = rotatePointAroundAxis(A_base_left, B_left, axisY, wallAngle - Math.PI/2);
  const u_new_left = rotateVectorAroundAxis(u_base_left, axisY, wallAngle - Math.PI/2);
  leftWall.origin.copy(A_new_left);
  leftWall.u.copy(u_new_left);
  leftWall.v.copy(vBase);

  // === RIGHT WALL ===
  const rightOrigin = new THREE.Vector3(150, -150, -150);
  const rightU = new THREE.Vector3(0,0,300).applyAxisAngle(axisY, Math.PI/2 - wallAngle);
  rightWall.origin.copy(rightOrigin);
  rightWall.u.copy(rightU);
  rightWall.v.copy(vBase);

  // === UPDATE GEOMETRIES ===
  for (let cube of displaySurfaceScene.children) {
    const surf = displaySurfaces.find(d => d.name === cube.name);
    if (!surf) continue;

    let p0, p1, p2, p3;

    if (surf.name === "Floor") {
      const v_BL = leftWall.origin;
      const v_FL = leftWall.origin.clone().add(leftWall.u);
      const v_FR = rightWall.origin;
      const v_BR = rightWall.origin.clone().add(rightWall.u);
      p0 = v_BL; p1 = v_BR; p2 = v_FR; p3 = v_FL;
    } else {
      const origin = surf.origin;
      const u = surf.u;
      const v = surf.v;
      p0 = origin; 
      p1 = origin.clone().add(u);
      p2 = origin.clone().add(u).add(v);
      p3 = origin.clone().add(v);
    }

    const posAttr = cube.geometry.getAttribute('position');
    posAttr.setXYZ(0, p0.x, p0.y, p0.z);
    posAttr.setXYZ(1, p1.x, p1.y, p1.z);
    posAttr.setXYZ(2, p2.x, p2.y, p2.z);
    posAttr.setXYZ(3, p3.x, p3.y, p3.z);
    posAttr.needsUpdate = true;
    cube.geometry.computeVertexNormals();
  }
}


// ============================================================
// === Eye + Head scene
// ============================================================
function createEyeScene() {
  const IPD = 6.8;
  eyeCenter = new THREE.Vector3(50, 20, 50);
  const eyeL = new THREE.Vector3(-IPD/2, 10, -6);
  const eyeR = new THREE.Vector3(IPD/2, 10, -6);

  eyeScene = new THREE.Scene();

  const headGeom = new THREE.SphereGeometry(10, 32, 22);
  const headMat = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
  
  headMesh = new THREE.Mesh(headGeom, headMat);
  headMesh.name = "Head";
  headMesh.position.copy(eyeCenter);
  eyeScene.add(headMesh);
  
  const eyeGeom = new THREE.SphereGeometry(3, 32, 22);
  
  eyeLMesh = new THREE.Mesh(eyeGeom, new THREE.MeshPhongMaterial({ color: 0xff0000 }));
  eyeLMesh.name = "EyeL";
  eyeLMesh.position.copy(eyeL);
  headMesh.add(eyeLMesh);

  eyeRMesh = new THREE.Mesh(eyeGeom, new THREE.MeshPhongMaterial({ color: 0x0000ff }));
  eyeRMesh.name = "EyeR";
  eyeRMesh.position.copy(eyeR);
  headMesh.add(eyeRMesh);

  createLights(eyeScene);
}

// ============================================================
// === WebXR setup
// ============================================================
function createRenderer() {
  renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true, antialias: true });
  renderer.autoClear = false;
  renderer.xr.enabled = true;
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  setupWebXRButton();
}

function setupWebXRButton() {
  const button = document.createElement('button');
  button.style.position = 'absolute';
  button.style.right = '10px';
  button.style.bottom = '10px';
  button.style.padding = '8px 12px';
  button.style.background = '#444';
  button.style.color = '#fff';
  button.style.border = 'none';
  button.style.borderRadius = '4px';
  button.style.cursor = 'pointer';
  button.style.zIndex = '999';
  button.textContent = 'Enter VR';

  if (navigator.xr) {
    navigator.xr.isSessionSupported('immersive-vr').then(supported => {
      if (!supported) button.style.display = 'none';
    });
  } else {
    button.style.display = 'none';
  }

  button.addEventListener('click', async () => {
    if (!xrSession) {
      try {
        const session = await navigator.xr.requestSession('immersive-vr', {
          optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'local']
        });
        if (renderer.xr.enabled) setupXRControllers();
        await onSessionStarted(session);
        button.textContent = 'Exit VR';
      } catch (err) {
        console.warn('XR session failed', err);
      }
    } else {
      xrSession.end();
      button.textContent = 'Enter VR';
    }
  });

  document.body.appendChild(button);
}

async function onSessionStarted(session) {
  xrSession = session;
  renderer.xr.setSession(session);
  session.addEventListener('end', () => { xrSession = null; });
  await session.requestReferenceSpace('local');
}

// ============================================================
// === Scene creation
// ============================================================
function createLights(scn) {
  const ambient = new THREE.AmbientLight(0x888888, 0.4);
  const point = new THREE.PointLight(0xffffff, 0.8);
  point.position.z += 200;
  scn.add(ambient, point);
}

function createScene() {
  scene = new THREE.Scene();
  const geometry = new THREE.TeapotGeometry(40, 15);
  const material = new THREE.MeshPhongMaterial({ color: 0xffffff });
  const teapot = new THREE.Mesh(geometry, material);
  teapot.name = "Teapot";
  teapot.position.z -= 70;
  scene.add(teapot);

  createLights(scene);
  const tubePath = new THREE.LineCurve3(
        new THREE.Vector3(0, 0, -100),
        new THREE.Vector3(0, 0, -200)
    );

    const tubeGeometry = new THREE.TubeGeometry(
        tubePath,
        20,
        10,
        8,
        false
    );

    const tubeMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xffffff,
        side: THREE.DoubleSide
    }); 

    const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
    tube.name = "Tube";
    
    scene.add(tube);
}

// ============================================================
// === Display surfaces and textures
// ============================================================
function createDisplaySurfaces() {
  displaySurfaces = [];
  displaySurfaces.push(new DisplaySurface("Front", new THREE.Vector3(-150, -150, -150), new THREE.Vector3(300,0,0), new THREE.Vector3(0,300,0)));
  displaySurfaces.push(new DisplaySurface("Left", new THREE.Vector3(-150, -150, 150), new THREE.Vector3(0,0,-300), new THREE.Vector3(0,300,0)));
  displaySurfaces.push(new DisplaySurface("Right", new THREE.Vector3(150, -150, -150), new THREE.Vector3(0,0,300), new THREE.Vector3(0,300,0)));
  displaySurfaces.push(new DisplaySurface("Floor", new THREE.Vector3(-150,-150,150), new THREE.Vector3(300,0,0), new THREE.Vector3(0,0,-300)));
}

function createDisplaySurfaceTargets() {
  const SIZE = 1024;
  displaySurfaceTargets = displaySurfaces.map(() => new THREE.WebGLRenderTarget(SIZE, SIZE));
}

function createDisplaySurfaceScene() {
  displaySurfaceScene = new THREE.Scene();
  displaySurfaces.forEach((surf, i) => {
    const origin = surf.origin;
    const u = surf.u;
    const v = surf.v;
    const geom = new THREE.BufferGeometry();
    const p0 = origin.clone();
    const p1 = origin.clone().add(u);
    const p2 = origin.clone().add(u).add(v);
    const p3 = origin.clone().add(v);
    const vertices = new Float32Array([
      p0.x,p0.y,p0.z, p1.x,p1.y,p1.z, p2.x,p2.y,p2.z, p3.x,p3.y,p3.z
    ]);
    const indices = [0,1,3,1,2,3];
    const uvs = new Float32Array([0,0,1,0,1,1,0,1]);
    geom.setAttribute('position', new THREE.BufferAttribute(vertices,3));
    geom.setAttribute('uv', new THREE.BufferAttribute(uvs,2));
    geom.setIndex(indices);
    geom.computeVertexNormals();
    const mat = new THREE.MeshPhongMaterial({ map: displaySurfaceTargets[i].texture, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.name = surf.name;
    displaySurfaceScene.add(mesh);
  });
  createLights(displaySurfaceScene);
}

// ============================================================
// === Camera, Controls, Helpers
// ============================================================
function createCamera() {
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 10000);
  camera.position.set(100, 100, 300);
  camera.lookAt(0,0,0);
}

function enableOrbitCamera(cam) {
  orbitControl = new THREE.OrbitControls(cam, renderer.domElement);
  orbitControl.minDistance = 120;
  orbitControl.maxDistance = 50000;
}

function addDragControlToObjects() {
    const teapot = scene.getObjectByName("Teapot");
    const head = headMesh; 
    const tube = scene.getObjectByName("Tube");
    
    if(teapot) grabbableObjects.push(teapot);
    if(head) grabbableObjects.push(head);
    if(tube) grabbableObjects.push(tube);
    if(eyeLMesh) grabbableObjects.push(eyeLMesh);
    if(eyeRMesh) grabbableObjects.push(eyeRMesh);

    const desktopObjects = grabbableObjects.filter(obj => obj);

    const controls = new THREE.DragControls(desktopObjects, camera, renderer.domElement);
  controls.addEventListener('hoveron', function ( event ) 
    {
            orbitControl.enabled = false;
            event.object.material.emissive.set( 0x2D2D2D );
        } );
  controls.addEventListener('hoveroff', function ( event ) 
    {
            orbitControl.enabled = true;
            event.object.material.emissive.set( 0x000000 );
        } );
  controls.addEventListener( 'dragstart', function ( event ) 
    {
            event.object.material.emissive.set( 0xaaaaaa );
        } );
    controls.addEventListener( 'dragend', function ( event ) 
    {
            if(orbitControl.enabled == false)
                event.object.material.emissive.set( 0x2D2D2D );
            else
                event.object.material.emissive.set( 0x000000 );
    } );
}

function updateXRControllerGamepads() {
  if (renderer.xr.isPresenting) {
    let ses = renderer.xr.getSession();
    let gamepads = navigator.getGamepads();
    for (let i = 0; i < ses.inputSources.length; i++) {
      let src = ses.inputSources[i];
      if (src && src.gamepad) {
        if (i === 0 && controllerL) controllerL.userData.gamepad = src.gamepad;
        if (i === 1 && controllerR) controllerR.userData.gamepad = src.gamepad;
      }
    }
  }
}


// ============================================================
// === Animation loop
// ============================================================
const clock = new THREE.Clock();

function animate() {
  updateXRControllerGamepads();
  checkXRControllerButtons();
  handleXRRaycaster();
  const delta = clock.getDelta();
  if (mixer) mixer.update(delta);
  renderer.setClearColor(0x808080);
  renderer.clear();

  const gl = renderer.getContext();
  if (showScene) renderer.render(scene, camera);

  const wasXREnabled = renderer.xr.enabled;
  renderer.xr.enabled = false;

  if (headMesh) headMesh.visible = false;
  if (eyeLMesh) eyeLMesh.visible = false;
  if (eyeRMesh) eyeRMesh.visible = false;

  const rayLine = controllerR ? controllerR.getObjectByName('rayLine') : null;
  if (rayLine) rayLine.visible = false;

  for (let [i, surf] of displaySurfaces.entries()) {
    renderer.setRenderTarget(displaySurfaceTargets[i]);
    renderer.setClearColor(0x404040);
    renderer.clear();

    gl.colorMask(1, 0, 0, 0);
    let eyeL = eyeLMesh ? eyeLMesh.getWorldPosition(new THREE.Vector3()) : new THREE.Vector3();
    let viewL = surf.viewMatrix(eyeL);
    let projL = surf.projectionMatrix(eyeL, 1, 1000);
    let camL = cameraFromViewProj(viewL, projL);
    renderer.render(scene, camL);

    gl.colorMask(0, 1, 1, 0);
    let eyeR = eyeRMesh ? eyeRMesh.getWorldPosition(new THREE.Vector3()) : new THREE.Vector3();
    let viewR = surf.viewMatrix(eyeR);
    let projR = surf.projectionMatrix(eyeR, 1, 1000);
    let camR = cameraFromViewProj(viewR, projR);
    renderer.clearDepth();
    renderer.render(scene, camR);
    gl.colorMask(1, 1, 1, 0);
  }

  if (headMesh) headMesh.visible = true;
  if (eyeLMesh) eyeLMesh.visible = true;
  if (eyeRMesh) eyeRMesh.visible = true;
  if (rayLine) rayLine.visible = true;

  renderer.xr.enabled = wasXREnabled;

  if (xrSession) {
    const ROTATE_SPEED = 0.05;
    const ZOOM_SPEED = 0.05;
    const PAN_SPEED = 0.05;

    if (controllerL && controllerL.userData && controllerL.userData.gamepad) {
      const gp = controllerL.userData.gamepad;
      let axes = gp.axes;
      if (Math.abs(axes[2]) > 0.1) {
        dolly.position.x += axes[2] * PAN_SPEED * 10;
      }
      if (Math.abs(axes[3]) > 0.1) {
        dolly.position.y -= axes[3] * PAN_SPEED * 10;
      }
    }
    if (controllerR && controllerR.userData && controllerR.userData.gamepad) {
      const gp = controllerR.userData.gamepad;
      let axes = gp.axes;
      if (Math.abs(axes[3]) > 0.1) {
        dolly.position.z += axes[3] * ZOOM_SPEED * 20;
      }
    }
  }


  renderer.setRenderTarget(null);
  renderer.setClearColor(0x000000);
  renderer.render(displaySurfaceScene, camera);
  renderer.render(eyeScene, camera);
}

// ============================================================
// === Init
// ============================================================
createRenderer();
createDisplaySurfaces();
createDisplaySurfaceTargets();
createDisplaySurfaceScene();
updateWallAngle();
createEyeScene();
createScene();
createCamera();
raycaster = new THREE.Raycaster();

const dolly = new THREE.Group();
dolly.name = "Dolly";
scene.add(dolly);

vrRig = new THREE.Group();
vrRig.name = "VRRig";
vrRig.add(camera);

dolly.add(vrRig);

enableOrbitCamera(camera);
addDragControlToObjects();
renderer.setAnimationLoop(animate);

// ============================================================
// === Keyboard events
// ============================================================
window.addEventListener('keydown', e => {
  switch(e.code) {
    case 'KeyL': if(eyeLMesh) camera.position.copy(eyeLMesh.getWorldPosition(new THREE.Vector3())); break;
    case 'KeyR': if(eyeRMesh) camera.position.copy(eyeRMesh.getWorldPosition(new THREE.Vector3())); break;
    case 'KeyS': showScene = !showScene; break;
    case 'KeyT': 
          var viewF = displaySurfaces[0].viewMatrix(new THREE.Vector3(50,20,100));
		var viewL = displaySurfaces[1].viewMatrix(new THREE.Vector3(50,20,100));
		var viewR = displaySurfaces[2].viewMatrix(new THREE.Vector3(50,20,100));
		var viewB = displaySurfaces[3].viewMatrix(new THREE.Vector3(50,20,100));
		console.log("View matrices:");
		console.log(viewF);
		console.log(viewL);
		console.log(viewR);
		console.log(viewB);
        var projF1 = displaySurfaces[0].projectionMatrix(new THREE.Vector3(0,0,0), 1, 1000);
		var projL1 = displaySurfaces[1].projectionMatrix(new THREE.Vector3(0,0,0), 1, 1000);
		var projR1 = displaySurfaces[2].projectionMatrix(new THREE.Vector3(0,0,0), 1, 1000);
		var projB1 = displaySurfaces[3].projectionMatrix(new THREE.Vector3(0,0,0), 1, 1000);
		console.log("Projection matrices 1:");
		console.log(projF1);
		console.log(projL1);
		console.log(projR1);
		console.log(projB1);
        var projF2 = displaySurfaces[0].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
		var projL2 = displaySurfaces[1].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
		var projR2 = displaySurfaces[2].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
		var projB2 = displaySurfaces[3].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
		console.log("Projection matrices 2:");
		console.log(projF2);
		console.log(projL2);
		console.log(projR2);
		console.log(projB2);
		break;
    case 'ArrowLeft': 
        wallAngle -= angleStep;
        wallAngle = Math.max(THREE.MathUtils.degToRad(60), wallAngle);
        updateWallAngle();
        break;
    case 'ArrowRight': 
        wallAngle += angleStep;
        wallAngle = Math.min(THREE.MathUtils.degToRad(120), wallAngle);
        updateWallAngle();
        break;
    case 'KeyM': wallAngle = Math.PI/2; updateWallAngle(); break;
  }
});

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

function cameraFromViewProj(view, proj) {
  const cam = camera.clone();
  const inv = new THREE.Matrix4().copy(view).invert();
  cam.position.set(inv.elements[12], inv.elements[13], inv.elements[14]);
  cam.setRotationFromMatrix(view);
  cam.projectionMatrix = proj.clone();
  return cam;
}
</script>
</body>
</html>